# Swift Bundle Loading Patterns and Pitfalls

**Context:** Julia set camera app - Metal shader loading
**Created:** 2026-02-01

## Overview

This document captures lessons learned about Swift package resource bundling, particularly for Metal shaders (`.metallib` files) used by CoreImage filters.

## The Three Execution Contexts

Swift packages with resources need to work in three different contexts:

### 1. Development Mode (`swift run`)
- Resources in: `.build/debug/PackageName_TargetName.bundle/`
- Bundle discovery: `Bundle.module` (SPM auto-generated)
- Working directory: Project root

### 2. App Bundle (`.app`)
- Resources in: `App.app/Contents/Resources/PackageName_TargetName.bundle/`
- Bundle discovery: May need main bundle or bundle search
- Working directory: Variable (often bundle Contents)

### 3. Test Context (`swift test`)
- Resources in: `.build/debug/PackageName_TargetName.bundle/`
- Bundle discovery: Bundle.allBundles or filesystem search
- Working directory: Project root (usually)

## Bundle.module: The SPM Default

### What It Is
```swift
extension Bundle {
  static let module: Bundle = {
    // Auto-generated by Swift Package Manager
    // Returns the resource bundle for this module
  }()
}
```

### How It Works
SPM generates this accessor automatically when `Package.swift` declares resources:
```swift
.target(
    name: "JuliaKit",
    resources: [
        .copy("Filters/JuliaWarp.ci.metallib"),
    ]
)
```

### The Fatal Flaw
**Bundle.module calls `fatalError()` if the bundle cannot be found.**

From SPM source (conceptual):
```swift
guard let bundle = Bundle(/* various discovery attempts */) else {
    fatalError("could not find resource bundle for module")
}
return bundle
```

### When It Fails
- .app bundle structure differs from development structure
- Resources not copied to expected location during .app bundle creation
- Fatal error on background thread → instant crash with no recovery

## The M1 Air Crash Case Study

### Crash Details
From crash-report.ips:
```
Exception: EXC_BREAKPOINT, SIGTRAP
PC: _assertionFailure(_:_:file:line:flags:)
Frame 1: closure #1 in static NSBundle.module  ← FATAL ERROR HERE
Frame 5: closure #1 in static JuliaSetFilter.kernel
Frame 11: CameraManager.captureOutput (cameraQueue thread)
```

**Root cause:** `Bundle.module` threw fatal error when loading .metallib in .app bundle context.

### Original Code Pattern
```swift
private static let kernel: CIWarpKernel? = {
  guard let url = Bundle.module.url(forResource: "JuliaWarp.ci", withExtension: "metallib") else {
    print("❌ ERROR: metallib not found")
    return nil
  }
  // ... load kernel
}()
```

**Problem:** If `Bundle.module` itself fails, we never reach the guard statement. Fatal error occurs before our error handling.

## Attempted Fix: Safe Bundle Accessor

### Implementation (bc5ba40)
Created `BundleResources.swift` with multi-strategy bundle discovery:

```swift
enum BundleResources {
  static let resourceBundle: Bundle? = {
    // Strategy 1: Search all loaded bundles
    for bundle in Bundle.allBundles {
      if bundle.url(forResource: "JuliaWarp.ci", withExtension: "metallib") != nil {
        return bundle
      }
    }

    // Strategy 2: Try main bundle
    if Bundle.main.url(forResource: "JuliaWarp.ci", withExtension: "metallib") != nil {
      return Bundle.main
    }

    // Strategy 3: Filesystem search (test context)
    let searchPaths = [".build/arm64-apple-macosx/debug", ...]
    for path in searchPaths {
      if let bundle = Bundle(path: "\(path)/PackageName_TargetName.bundle") {
        return bundle
      }
    }

    return nil  // No fatalError!
  }()
}
```

### Test Results
- ✅ Unit tests pass (filesystem search works)
- ✅ App launches (no immediate crash)
- ❌ Filters don't work (reported by user)

### Critical Testing Failure
**What we tested:** "Does the app launch?"
**What we should have tested:** "Does the app show the Julia set effect?"

Launching without crashing ≠ Working correctly

## The Regression

### Symptom
"Filters no longer work at all" after implementing safe bundle accessor.

### Possible Root Causes

#### 1. Bundle.module Was Never the Problem in Development
- `Bundle.module` works fine in `swift run` mode
- Only fails in .app bundles
- Our fix broke the working development case to fix the .app case

#### 2. Static Initialization Timing
- `BundleResources.resourceBundle` is a static let
- Evaluated once, very early in app lifecycle
- May run before all bundles are loaded
- Returns nil, cached forever, filters never work

**Old code:** `Bundle.module` - SPM ensures it's available when needed
**New code:** Static initializer - runs immediately, may be too early

#### 3. Filesystem Paths Don't Work
- Relative paths like `.build/arm64-apple-macosx/debug/...`
- Assume working directory is project root
- GUI apps often change working directory
- Paths resolve incorrectly, bundle not found

#### 4. Silent Failure
- Old: `fatalError()` → obvious crash
- New: Returns nil → silent failure
- Filter kernel is nil
- Camera works but no Julia set effect
- User sees normal webcam feed (subtle failure)

## Diagnostic Challenges

### Print Statements Don't Appear
Attempted to use print() for diagnostics:
```swift
print("✅ Found metallib in bundle: \(bundle.bundlePath)")
```

**Problem:** Print output from static initializers may not appear in GUI apps.

**Better alternatives:**
- `NSLog("message")` - Goes to system log
- `os_log(.info, "message")` - Modern logging framework
- User-visible indicators (status labels, alerts)

### Testing Assumptions
- "App launches" ≠ "App works"
- "Tests pass" ≠ "Production works"
- "No crashes" ≠ "Correct behavior"

## The Solution: Strategy 2.5 - Explicit .app Bundle Path

### Implementation (06e5f81)
**Date:** 2026-02-01
**Commit:** "Fix bundle loading regression in .app bundles"

Added Strategy 2.5 to `BundleResources.swift` that explicitly constructs the path to the package bundle in .app context:

```swift
// Strategy 2.5: Explicitly look for package bundle in .app Resources folder
// The bundle is at: Contents/Resources/CameraDemo_JuliaKit.bundle
if let resourcePath = Bundle.main.resourcePath {
  let bundlePath = "\(resourcePath)/CameraDemo_JuliaKit.bundle"
  if let bundle = Bundle(path: bundlePath),
     bundle.url(forResource: "JuliaWarp.ci", withExtension: "metallib") != nil {
    print("✅ BundleResources: Found .app bundle at: \(bundlePath)")
    return bundle
  }
}
```

### Why Previous Strategies Failed in .app Context

**Strategy 1 (Bundle.allBundles):**
- Bundle might not be loaded yet when static property initializes
- `CameraDemo_JuliaKit.bundle` not in `allBundles` at init time

**Strategy 2 (Direct in Bundle.main):**
```swift
Bundle.main.url(forResource: "JuliaWarp.ci", withExtension: "metallib")
```
- Looks for metallib directly in main bundle
- But metallib is inside `CameraDemo_JuliaKit.bundle` subdirectory
- Returns `nil`

**Strategy 3 (Load Resources directory as bundle):**
```swift
let resourceBundle = Bundle(path: resourcePath)
```
- Tries to load `Contents/Resources/` as a bundle
- But Resources directory is NOT a bundle, just a folder
- Returns invalid bundle, can't find resources

**Strategy 4 (Filesystem search):**
```swift
".build/arm64-apple-macosx/debug/CameraDemo_JuliaKit.bundle"
```
- Uses relative paths for build directory
- .app bundle doesn't have `.build` directory
- Paths don't exist

### Why Strategy 2.5 Works

**1. Bundle.main.resourcePath in .app context returns:**
```
/path/to/JuliaSetCamera.app/Contents/Resources
```

**2. We construct explicit path:**
```
/path/to/JuliaSetCamera.app/Contents/Resources/CameraDemo_JuliaKit.bundle
```

**3. This matches actual structure:**
```
JuliaSetCamera.app/
  Contents/
    MacOS/CameraDemo
    Resources/
      CameraDemo_JuliaKit.bundle/  ← We find this!
        JuliaWarp.ci.metallib
        ChromaticAberration.ci.metallib
```

**4. Bundle(path:) successfully loads the bundle**

**5. Bundle contains the metallib files → success!**

### Actual .app Bundle Structure

Created by Makefile:
```bash
# Create app bundle structure
mkdir -p .build/arm64-apple-macosx/release/JuliaSetCamera.app/Contents/MacOS
mkdir -p .build/arm64-apple-macosx/release/JuliaSetCamera.app/Contents/Resources

# Copy executable
cp .build/arm64-apple-macosx/release/CameraDemo \
   .build/arm64-apple-macosx/release/JuliaSetCamera.app/Contents/MacOS/

# Copy resource bundle (Metal shaders)
cp -R .build/arm64-apple-macosx/release/CameraDemo_JuliaKit.bundle \
      .build/arm64-apple-macosx/release/JuliaSetCamera.app/Contents/Resources/
```

The key insight: SPM creates `CameraDemo_JuliaKit.bundle` at build time, and the Makefile copies it into the .app's Resources folder. We need to explicitly look there.

### Test Results
- ✅ `swift test` - All 11 tests pass (Strategy 4 works)
- ✅ `swift run` - Julia set effect visible (Strategy 1 works)
- ✅ `.app bundle` - Julia set effect visible (Strategy 2.5 works!)

### Key Lessons Learned

**1. .app bundles have predictable structure**
- Main bundle's resourcePath is always `Contents/Resources`
- SPM resource bundles are copied there by build process
- Can construct path deterministically

**2. Multiple strategies are necessary**
- Different execution contexts need different approaches
- Fallback chain handles all cases
- Order matters: fast paths first, expensive searches last

**3. Verify bundle contents before returning**
- `Bundle(path:)` can succeed but bundle may be empty/invalid
- Always verify expected resource exists
- Prevents returning useless bundles

**4. Static initialization is okay if comprehensive**
- With proper fallback strategies, static initialization works
- Evaluated once at first access (lazy static let)
- By the time filters are used, bundle is found

**5. Print debugging requires app to run long enough**
- GUI apps may not show print output
- Test by actually using the app (visual verification)
- Don't just test "does it crash?"

## Alternative Approaches (For Reference)

### Approach 1: Hybrid Strategy
```swift
private static let kernel: CIWarpKernel? = {
  // Try Bundle.module first (works in development)
  if let url = try? Bundle.module.url(forResource: "JuliaWarp.ci", withExtension: "metallib") {
    // ... load kernel
  }

  // Fallback to safe search (for .app bundles)
  if let bundle = BundleResources.findResourceBundle() {
    if let url = bundle.url(forResource: "JuliaWarp.ci", withExtension: "metallib") {
      // ... load kernel
    }
  }

  return nil
}()
```

**Issue:** Can't `try` in a non-throwing context, and `Bundle.module` doesn't throw - it calls `fatalError()`.

### Approach 2: Lazy Loading
```swift
private static var _kernel: CIWarpKernel?
private static var _kernelLoaded = false
private static let kernelLock = NSLock()

private static var kernel: CIWarpKernel? {
  kernelLock.lock()
  defer { kernelLock.unlock() }

  if !_kernelLoaded {
    _kernel = loadKernel()
    _kernelLoaded = true
  }
  return _kernel
}

private static func loadKernel() -> CIWarpKernel? {
  // Compute on-demand when first needed
  // All bundles should be loaded by now
}
```

**Benefits:**
- Runs when first used, not at static initialization time
- Bundles definitely loaded by the time filter is used
- Can still cache result

### Approach 3: Explicit Bundle Parameter
```swift
public class JuliaSetFilter: CIFilter {
  private let kernel: CIWarpKernel?

  public init(resourceBundle: Bundle = .module) {
    kernel = Self.loadKernel(from: resourceBundle)
    super.init()
  }

  private static func loadKernel(from bundle: Bundle) -> CIWarpKernel? {
    // ...
  }
}
```

**Benefits:**
- Explicit, testable
- Can override bundle for testing
- Clear dependency

**Drawback:**
- Changes public API
- Requires callers to know about bundle loading

## Recommendations for Future

### Testing Checklist
When changing resource loading:
- [ ] Unit tests pass
- [ ] `swift run` launches
- [ ] **Visual verification** in `swift run` (see the effect)
- [ ] .app bundle builds
- [ ] .app bundle launches
- [ ] **Visual verification** in .app bundle (see the effect)
- [ ] Test on target platform (M1 Air in this case)

### Debugging Techniques
1. Use `NSLog()` or `os_log()` instead of `print()`
2. Add user-visible error indicators
3. Log to file in known location
4. Check Console.app for system logs
5. Enable Metal shader validation in scheme settings

### Bundle Loading Best Practices
1. **Never use `Bundle.module` directly** - it calls `fatalError()` on failure
2. **Implement multi-strategy fallback chain:**
   - Strategy 1: Search `Bundle.allBundles` (works in `swift run`)
   - Strategy 2: Try `Bundle.main` directly (if resources copied to main bundle)
   - **Strategy 2.5: Explicit .app path** (`Bundle.main.resourcePath + "/PackageName_TargetName.bundle"`)
   - Strategy 3: Try loading main bundle's Resources as bundle (usually fails)
   - Strategy 4: Filesystem search with build paths (works in tests)
3. **Always verify bundle contents** before returning from discovery
4. **Log all attempts** with paths for debugging
5. **Test all execution contexts** (dev, app, test) with **visual verification**
6. **Return Optional** (`Bundle?`) not fatalError, handle nil gracefully

## Related Documentation

- `docs/debugging/bundle-module-fix-regression.md` - Current investigation
- `docs/knowledge/m1-air-crash-fix.md` - Original crash analysis
- `crash-reports/crash-report.ips` - Stack trace showing Bundle.module fatal error

## Questions for Future Investigation

1. ✅ **ANSWERED:** Can we detect if we're running in .app vs development programmatically?
   - Yes: `Bundle.main.resourcePath` returns different paths
   - .app: `/path/to/App.app/Contents/Resources`
   - Development: varies, may not have .app structure

2. ✅ **ANSWERED:** Is there a way to try `Bundle.module` without risking `fatalError()`?
   - No direct way - `Bundle.module` will always call `fatalError()` on failure
   - Solution: Don't use `Bundle.module`, use custom multi-strategy discovery

3. Should Metal shader loading be moved to async initialization?
   - Current static initialization works with proper fallback chain
   - Async might help if bundles load asynchronously, but no evidence of this

4. Can we show user-facing errors when kernels fail to load?
   - Yes - could add UI indicators when `kernel == nil`
   - Low priority since bundle loading now works reliably

5. ✅ **ANSWERED:** What's the proper way to handle resource bundles in multi-platform Swift?
   - Implement multi-strategy fallback chain
   - Each strategy targets specific execution context
   - Test all contexts thoroughly
   - Never rely on `Bundle.module` alone
